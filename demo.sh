#!/usr/bin/env bash
# Generated by Gemini 2.5 Pro from code blocks in post and touched up manually
#
# Usage: bash demo.sh https://oauth-app.example.com
set -eo pipefail

# --- Configuration ---
# Replace this with the Fully Qualified Domain Name (FQDN) of your deployed PoC application.
export THIS_ENDPOINT="${1}"
# Replace with your desired Droplet region.
export DROPLET_REGION="sfo3"
# Replace with the fingerprint or ID of the SSH key you want to use for the new Droplet.
export SSH_KEY_FINGERPRINT_OR_ID="$(ssh-keygen -l -E md5 -f ~/.ssh/id_*.pub | head -n 1 | awk '{print $2}' | sed -e 's/MD5://1')"


# --- Global State ---
# These are used for execution and cleanup.
DROPLET_NAME="workload-poc-$(date +%s)"
DROPLET_ID=""
DROPLET_IPV4=""
LOCAL_USAGE_SCRIPT="usage_on_droplet.sh"

# --- Cleanup Function ---
# This function is called on script exit to remove created resources.
function cleanup() {
    echo ""
    print_header "🧹 Performing Cleanup"

    # Remove the temporary usage script if it exists
    if [ -f "${LOCAL_USAGE_SCRIPT}" ]; then
        echo "--> Removing local usage script..."
        rm -f "${LOCAL_USAGE_SCRIPT}"
    fi

    # Delete the Droplet if its ID was captured
    if [ -n "${DROPLET_ID}" ]; then
        echo "--> Deleting Droplet ID: ${DROPLET_ID}..."
        # Silence errors in case droplet was already deleted
        doctl compute droplet delete "${DROPLET_ID}" --force || echo "--> Droplet already deleted or failed to delete."
    fi

    # Remove the local rbac directory if it exists
    if [ -d "rbac" ]; then
        echo "--> Removing local rbac directory..."
        rm -rf rbac
    fi
    echo "✅ Cleanup complete."
}
trap cleanup EXIT


# --- Helper Functions ---
function print_header() {
    echo ""
    echo "======================================================================"
    echo "    $1"
    echo "======================================================================"
    echo ""
}

# --- Script Sections ---

function setup_rbac_policies() {
    print_header "Part 1: Setting up RBAC Roles and Policies"
    # The setup for RBAC policies remains the same. [cite: 154-156, 226-227]
    echo "--> Creating local directory for RBAC configuration..."
    mkdir -p rbac/policies rbac/droplet-roles rbac/roles rbac/scripts
    cd rbac

    echo "--> Writing policy: ex-droplet-readwrite.hcl" # [cite: 162-163]
    tee policies/ex-droplet-readwrite.hcl <<'EOF'
path "/v1/oidc/issue" {
  capabilities = ["create"]
  allowed_parameters = {
    "aud" = "api://DigitalOcean?team={team}"
    "sub" = "role:data-readwrite"
    "ttl" = 300
  }
}
EOF

    echo "--> Writing role: ex-droplet-readwrite.hcl" # [cite: 174]
    tee droplet-roles/ex-droplet-readwrite.hcl <<'EOF'
role "ex-droplet-readwrite" {
  audience         = "api://DigitalOcean?team={team}"
  subject          = "role:ex-droplet-readwrite"
  token_policies   = ["ex-droplet-readwrite"]
}
EOF

    echo "--> Writing policy: data-readwrite.hcl" # [cite: 182-183]
    tee policies/data-readwrite.hcl <<'EOF'
path "/v2/databases/13d94fe3-7e6c-4c24-bd3a-686c337c1a00" {
  capabilities = ["read"]
}
path "/v2/databases" {
  capabilities = ["read"]
  allowed_parameters = {
    "?" = { "tag_name" = "my-tag-1" }
  }
}
path "/v2/spaces/keys" {
  capabilities = ["create"]
  allowed_parameters = {
    "name" = "*"
    "grants" = [ { "bucket" = "111", "permission" = "read" } ]
  }
}
path "/v2/spaces/keys/*" {
  capabilities = ["delete"]
}
EOF

    echo "--> Writing role: data-readwrite.hcl" # [cite: 218]
    tee roles/data-readwrite.hcl <<'EOF'
role "data-readwrite" {
  audience         = "api://DigitalOcean?team={team}"
  subject          = "role:data-readwrite"
  token_policies   = ["data-readwrite"]
}
EOF

    echo "--> Creating git credential helper script..." # [cite: 227]
    tee "scripts/git-credential.sh" <<'EOF'
#!/usr/bin/env bash
TOKEN=$(doctl auth token)
while IFS='=' read -r key value; do
  if [[ -n "$key" && -n "$value" ]]; then
    if [[ "$key" == "protocol" || "$key" == "host" ]]; then
      echo "$key=$value"
    fi
  fi
done
echo "username=token"
echo "password=${TOKEN}"
EOF
    chmod 755 scripts/git-credential.sh

    echo "--> Initializing Git repository and pushing policies to the API proxy..."
    git init
    git config --replace-all --global credential."${THIS_ENDPOINT}".helper '!'"${PWD}/scripts/git-credential.sh"
    git branch -M main
    git add .
    git config user.name "$(git config user.name || echo "Test Example")"
    git config user.email "$(git config user.email || echo "test@example.com")"
    git commit -sm "feat: configure access from droplet"
    if ! git remote | grep -q "deploy"; then
      git remote add deploy "${THIS_ENDPOINT}"
    fi
    git push -f -u deploy main
    git fetch --all && git show deploy/schema:rbac.json | yq -P
    echo "✅ RBAC setup complete."
    cd ..
}

function create_droplet() {
    print_header "Part 2: Creating Droplet and Waiting for Provisioning"

    echo "--> Creating a new Droplet named '${DROPLET_NAME}' with the 'ex-droplet-readwrite' role..."

    # Create the droplet and capture its ID for later use (especially cleanup) [cite: 257-268]
    DROPLET_ID=$(doctl \
      --api-url "${THIS_ENDPOINT}" \
      compute droplet create \
      --region "${DROPLET_REGION}" \
      --size s-1vcpu-1gb \
      --image ubuntu-24-04-x64 \
      --tag-names "oidc-sub:role:ex-droplet-readwrite" \
      --ssh-keys "${SSH_KEY_FINGERPRINT_OR_ID}" \
      --wait \
      "${DROPLET_NAME}" \
      --format ID --no-header)

    if [ -z "${DROPLET_ID}" ]; then
        echo "❌ Failed to create Droplet. Exiting."
        exit 1
    fi
    echo "--> Droplet created with ID: ${DROPLET_ID}"

    echo "--> Waiting for Droplet to become active and get an IP address..."
    while [[ -z "${DROPLET_IPV4}" ]]; do
        DROPLET_IPV4=$(doctl compute droplet get "${DROPLET_ID}" --format PublicIPv4 --no-header)
        sleep 2
    done
    echo "✅ Droplet is active at IP: ${DROPLET_IPV4}"
}

function execute_on_droplet() {
    print_header "Part 3: Automating Token Usage on the Droplet"

    # Create a local script file with the commands to be executed on the droplet.
    echo "--> Preparing usage script to run remotely..." # [cite: 279]
    tee "${LOCAL_USAGE_SCRIPT}" <<'EOF'
#!/usr/bin/env bash
set -euxo pipefail

echo "--- Running on Droplet ---"

# 1. Retrieve the provisioned credentials from the filesystem [cite: 280-283]
URL=$(cat /root/secrets/digitalocean.com/serviceaccount/base_url)
TEAM_UUID=$(cat /root/secrets/digitalocean.com/serviceaccount/team_uuid)
EXTOKEN=$(cat /root/secrets/digitalocean.com/serviceaccount/token)

# 2. Exchange the workload token for a short-lived access token [cite: 285, 288-295]
SUBJECT="role:data-readwrite"
TOKEN=$(curl -sf \
  -H "Authorization: Bearer ${EXTOKEN}" \
  -d@<(jq -n -c \
    --arg aud "api://DigitalOcean?team=${TEAM_UUID}" \
    --arg sub "${SUBJECT}" \
    --arg ttl 300 \
    '{aud: $aud, sub: $sub, ttl: ($ttl | fromjson)}') \
  "${URL}/v1/oidc/issue" \
  | jq -r .token)

echo "--> Successfully exchanged for a short-lived token."

# 3. Use the new token to access database connection strings [cite: 297-307]
DATABASE_UUID="13d94fe3-7e6c-4c24-bd3a-686c337c1a00"
echo "--> Fetching DB connection URI by UUID:"
curl -sf \
  -H "Authorization: Bearer ${TOKEN}" \
  "${URL}/v2/databases/${DATABASE_UUID}" \
  | jq -r .database.connection.uri

echo "--> Fetching DB connection URI by tag:"
curl -sf \
  -H "Authorization: Bearer ${TOKEN}" \
  "${URL}/v2/databases?tag_name=my-tag-1" \
  | jq -r .databases[].connection.uri

# 4. Use the token to create a new Spaces access key [cite: 309-315]
echo "--> Creating new Spaces key:"
curl -X POST \
  -H "Authorization: Bearer ${TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{"name": "key-from-droplet", "grants": [{"bucket":"111", "permission":"read"}]}' \
  "${URL}/v2/spaces/keys" \
  | jq

echo "--- Droplet Execution Finished ---"
EOF

    echo "--> Waiting for workload identity token to be provisioned by the PoC server..."
    # The script will poll the Droplet until the token file exists, indicating the cloud-init and attestation flow is complete. [cite: 271-274]
    while ! ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "root@${DROPLET_IPV4}" '[ -f /root/secrets/digitalocean.com/serviceaccount/token ]'; do
        echo "    Token file not found, waiting 1 second..."
        sleep 1
    done
    echo "--> Token file found!"

    echo "--> Copying usage script to Droplet..."
    scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "${LOCAL_USAGE_SCRIPT}" "root@${DROPLET_IPV4}:/root/"

    echo "--> Executing script on Droplet..."
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "root@${DROPLET_IPV4}" "chmod +x /root/${LOCAL_USAGE_SCRIPT} && /root/${LOCAL_USAGE_SCRIPT}"

    echo "✅ Remote execution complete."
}


# --- Main Execution ---
setup_rbac_policies
create_droplet
execute_on_droplet

print_header "✅ Script Finished Successfully"
